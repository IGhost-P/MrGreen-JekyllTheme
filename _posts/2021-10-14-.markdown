---
# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
lng_pair: id_autogeneratedsamplecontent_5
title: ATOMIC 폴더 구조

# post specific
# if not specified, .name will be used from _data/owner.yml
#author: ""
# multiple category is not supported
category: auto generated
# multiple tag entries are possible
tags: [jekyll, test]
# thumbnail image for post
img: ":post_pic2.jpg"
# disable comments on this page
comments_disable: true

# publish date
date: 2021-10-14 18:47:35 +0900

# seo
# if not specified, date will be used.
#meta_modify_date: 2021-10-14 18:47:35 +0900
# check the meta_common_description in _data/lang/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file
#published: false
---

{%- comment -%} Please delete below and place your page content here {%- endcomment -%}

{%- include util/auto-content-generator.liquid -%}

<!-- outline-start -->
# ATOMIC Design?

> 가장 작은 컴포넌트 단위를 원자로 설정하고 이를 바탕으로 상위 컴포넌트를 만들어 코드를 재사용을 최대화 하는 방법이다
> 

[Every UIUX designers follow Atomic Design System Guideline | 2019 Trends](https://www.youtube.com/watch?v=aMtnGeiWTyU)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8083ea32-900a-4621-8a66-081f203da623/Untitled.png)

- Atom
- Molecules
- Organisms
- Templates
- pages

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/54f81177-b047-4872-b86b-ccaa070e9898/Untitled.gif)

## ATOM(원자)

- #Generic #Abstract
- 가장 작은 단위의 컴포넌트
- 원자는 어떠한 context가 주어지든지 이에 해당하는 컴포넌트가 생성될 수 있어야한다
- 다양한 state를 가지고 있어야 하며 추상적이지만 최대한 포용할수 있게 설계되어야한다
    - ex) button: disabled, hover, different sizes, etc.
- **원자는 마진이나 위치값을 가지고 있지 않는다**

## **Molecule(분자)**

- #LittleComplex
- 원자를 엮어 조금 복잡한 단위의 분자가 생성된다
- 분자는 분자만의 프로퍼티를 가지고 있을 수 있고, 이를 활용해 원자에 기능을 만들어 줄수 있다
- **분자가 원자의 위치값을 지정하기도 한다**

## **Organism(유기체)**

- #MoreComplex
- 유기체는 분자를 엮에 만들어서 생성되고때로는 분자가 되지 않은 원자 엮이기도 한다
- 유기체가 완성되면 컴포넌트가 최종 모습을 가지게 된다
- **하지만 여전히 contents에 따라 최대한 재사용성 높게 개발하는 것이 중요하다**
- **유기체는 분자와 원자의 위치값을 조정한다**

## **Template(템플릿)**

- #Layout #NoStyling
- 템플릿은 만들어진 유기체와 컴포넌트의 **positions, placements**을 정해주는 역할을 한다
- 단, 템플릿에는 Styling이나 Color는 들어가지 않는다
- **템플릿의 역할은 페이지의 그리드를 정해주는 역할 뿐이다**

## Page(페이지)

- #Final
- 페이지는 템플릿을 이용해서 각 그리드에 컴포넌트를 그려서 디스플레이한다.

### 🤔 왜 리액트에서 아토믹 디자인이 갑자기 유행하기 시작했을까

# 리액트에서 컴포넌트

- 컴포넌트 기반의 프로그래밍
- 설계 우선 접근법을 권장
- UX / UI 팀이 개발자들이 구현할 수 있는 목접을 만듬
- 개발자들은 이를 이용해 UI를 컴포넌트 계층으로 세분화 할 수 있다

# 장점

1. 어플리케이션과 분리하여 컴포넌트를 개발하고 테스트할 수 있으며, 스타일 가이드와 같은 도구에서 볼 수 있다. 그리고 통합 개발을 할 때, 백엔드 어플리케이션의 로직에 의존하지 않는다는 장점이 있다.
2. 일련의 패턴이 확립되면, 설계 변경이 필요한 경우에 대비하여 더 빠르고 유연성 있는 빌드 프로세스를 가질 수 있다. 또한 기존의 컴포넌트들을 재사용하고 있기 때문에 디자인을 일관성 있게 통일할 수 있다.
3. 특정 컴포넌트에 CSS가 강하게 결합되어 있기 때문에 CSS를 훨씬 잘 관리할 수 있다. 이를 위해서는 어플리케이션의 구조에 따라 컴포넌트에서 사용되는 CSS만 렌더링하도록 해야 한다.

# 단점

1. 컴포넌트가 분리되어 있고 상위 컨테이너 컴포넌트의 사이즈를 결정할 수 없을 경우, 미디어쿼리를 사용하기 어렵다. 컴포넌트는 너비에 대해 알 수 없기 때문에 실제 페이지의 사이즈가 변경될 때 크기가 조정된다.
2. 이 문제는 크기를 조정할 수 있는 flex, grid 와 같은 CSS 속성을 구현한 레이아웃 컴포넌트를 도입하여 해결 할 수 있다.

# 마무리

위의 폴더 구조 이미지에서 어플리케이션은 단지 컴포넌트들로만 구성되어 있다. 컴포넌트들을 업데이트하기 위해 필요한 것은 비즈니스 로직을 가져오는 것이다. 필자는 뷰와 비즈니스 로직을 분리하는 것(관심사의 분리)이 좋은 방법이라고 생각한다. 이렇게 하면 프로젝트가 확장될 때 코드에서 문제를 디버깅하기 더 쉽다. 우리는 다른 접근법을 적용하여 관심사의 분리를 적용할 수 있었다. 개인적으로 고차 컴포넌트(HOC) 사용을 선호하기때문에 이를 이용하여 props로 특정 페이지의 상태를 변경하였다. 이 상태는 어플리케이션에서 공유되는 일련의 API 호출일 수도 있다. 다른 해결 방법으로는 render props 또는 리액트 hook이 있다.

좀 더 추상적으로 설명하자면, 어플리케이션의 컴포넌트들은 아래 이미지처럼 동일한 색상과 크기를 가진 빈 병이라고 할 수 있다. 각각의 병을 다른 색으로 채운다고 생각해보자. 이 과정은 컴포넌트의 상태를 업데이트하는 것으로 비유할 수 있다. 빈 병에 색을 채우는 것은 쉬운 일이고, 색을 바꾸는 상태 변경이 있더라도 빈 병에 넣을 색을 변경하는 것이기 때문에 쉬운 과정이 될 것이다.

하지만 만약 병을 빨간 색으로 반쯤 채우고 다른 색으로 나머지를 채운다고 한다면 문제가 있을 것이다. 그 색이 잘 섞이지 않는다면? 또는 원래의 색을 제거하고 다른색으로 대체해야한다면? 이것은 비즈니스 로직을 구현할 때도 발생할 수 있는 문제로 코드 리팩터링과 컴포넌트 재사용을 어렵게 만든다.

### 참고

[https://zoomkoding.github.io/디자인패턴/우아한테크캠프/2020/07/09/atomic-design-pattern.html](https://zoomkoding.github.io/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BA%A0%ED%94%84/2020/07/09/atomic-design-pattern.html)

[https://ui.toast.com/weekly-pick/ko_20200213](https://ui.toast.com/weekly-pick/ko_20200213)